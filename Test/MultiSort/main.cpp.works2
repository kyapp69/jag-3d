#include <stdio.h>
#include <vector>
#include <map>
#include <string>
#include <algorithm>


//////////////////////////////////////

// This is just another form of typedef (with templates)
template <class T>
struct priority_list: public std::vector<T> {};

// T = category (key to maps)
// U = values of maps
template <class T, class U>
class categorized_set: public std::map<T,U>
{
    public:
        bool contains( T t) const
        {
            typename categorized_set<T,U>::const_iterator p = this->find( t );
            return p == this->end() ? false: true;
        }
    
        bool contains( T t, U &u) const
        {
            typename categorized_set<T,U>::const_iterator p = find( t );
            if( p == this->end() )
                return false;
            u = p->second;
            return true;
        }


        categorized_set<T,U> operator +( const categorized_set &rhs )
        {

        }
};

template <class T,class U>
class categorized_set_sorter
{
    public:

        categorized_set_sorter() {}

        categorized_set_sorter( priority_list<T> &plist ):
            m_priority_list( plist)
        {}

        categorized_set_sorter( const categorized_set_sorter &c ):
            m_priority_list( c.m_priority_list )
        {}

        bool operator() ( const categorized_set<T,U> &lhs, const categorized_set<T,U> &rhs )
        {
            for( typename priority_list<T>::const_iterator p = m_priority_list.begin() ; p != m_priority_list.end(); p++ )
            {
                unsigned int n = 0;
                U a, b;
                if( lhs.contains(*p, a) ) n |= 1<<0;
                if( rhs.contains(*p, b) ) n |= 1<<1;
                switch( n )
                {
                    case 0: continue;
                    case 1: return false;
                    case 2: return true;
                }
                // both categories exist in the list.  Test for < or > 
                if( a < b ) { return true; }
                if( a > b ) { return false; }

                // attributes in this category are equivalent.  Continue to next category.
            }

            // return an aribitrary true.  
            return true;
        }

    protected:
        priority_list<T> m_priority_list;

};

// Debug convenience

enum Category{ 
    ID,
    S,
    T,
    U,
    V,
};

Category c[] = { ID, S, T, U, V };

std::map<Category,std::string> catname;

class Start
{
    public:
        Start()
        {
            catname[ID] = "ID";
            catname[S] = "S";
            catname[T] = "T";
            catname[U] = "U";
            catname[V] = "V";
        }
}start;


class Attribute
{
    public:
        Attribute(): m_val(0) {}

        Attribute( int n ):
            m_val(n)
        {}

        Attribute( const Attribute &a ):
            m_val(a.m_val)
        {}

        virtual bool operator < (const Attribute &rhs) const
        {
            return m_val < rhs.m_val;
        }

        virtual bool operator > (const Attribute &rhs) const
        {
            return m_val > rhs.m_val;
        }

        int getVal() const { return m_val; }

    private:
        int m_val;
};


typedef categorized_set<Category,Attribute> StateSet;

void printList( std::vector<StateSet> &l )
{
    printf("%4s %4s %4s %4s %4s\n", "ID", "S", "T", "U", "V" );
    printf("%4s %4s %4s %4s %4s\n", "--", "-", "-", "-", "-" );
    for( std::vector<StateSet>::iterator p = l.begin(); p != l.end(); p++ )
    {
        for( unsigned int i = 0; i < sizeof(c)/sizeof(Category); i++ )
        {
            StateSet::const_iterator q = p->find(c[i]);
            if( q == p->end() )
                printf("%4s ", " " );
            else
                printf("%4u ", q->second.getVal() );
        }
        printf("\n" );
    }
}

int main( int argc, char **argv )
{
    //std::vector<Category> priorityList;
    priority_list<Category>priorityList;
    //priorityList.push_back( ID );
    priorityList.push_back( S );
    priorityList.push_back( T );
    priorityList.push_back( U );
    priorityList.push_back( V );

    StateSet ss1;

    ss1[ID] = 1;
    ss1[S] = Attribute(1);
    ss1[T] = Attribute(2);
    ss1[U] = Attribute(2);
    ss1[V] = Attribute(1);

    StateSet ss2;
    ss2[ID] = 2;
    ss2[S] = Attribute(1);
    ss2[T] = Attribute(1);

    StateSet ss3;
    ss3[ID] = 3;
    ss3[S] = Attribute(1);
    ss3[T] = Attribute(1);
    ss3[U] = Attribute(1);
    ss3[V] = Attribute(1);


    std::vector<StateSet> l;
    l.push_back( ss3 );
    l.push_back( ss1);
    l.push_back( ss2);
    printf("B4 sort: (%lu)\n", l.size()  );
    printList( l );


//    puts("--BEGIN Sort---" );

    categorized_set_sorter<Category,Attribute> css( priorityList );

    std::sort( l.begin(), l.begin() + l.size(), css );

//    puts("--END Sort---" );

    printf("After sort: (%lu)\n", l.size() );

    printList( l );


    return 0;
}
