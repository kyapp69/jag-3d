#include <stdio.h>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include "Comparitor.h"



template <class T, class U>
class categorized_set: public std::map<T,U>
{
    public:

        bool contains( T t) const
        {
            typename categorized_set<T,U>::const_iterator p = this->find( t );
            return p == this->end() ? false: true;
        }
    
        bool contains( T t, U &u) const
        {
            typename categorized_set<T,U>::const_iterator p = find( t );
            if( p == this->end() )
                return false;
            u = p->second;
            return true;
        }
};

template <class T>
class priority_list: public std::vector<T>
{
};


template <class T, class U>
class sortable_categorized_set
{
    public:
        sortable_categorized_set( priority_list<T> priorityList, categorized_set <T,U> cset ):
            m_plist(priorityList),
            m_cset(cset)
        {
        }

        sortable_categorized_set( const sortable_categorized_set &s ):
            m_plist(s.m_plist),
            m_cset( s.m_cset )
        {
        }

        sortable_categorized_set& operator=(const sortable_categorized_set &s) 
        {
            m_plist = s.m_plist;
            m_cset  = s.m_cset;
            return *this;
        }

        const categorized_set<T,U> &getCategorizedSet() const { return m_cset; }

        bool operator < ( const sortable_categorized_set &rhs_csc ) const
        {
            const categorized_set<T,U> &lhs = m_cset;
            const categorized_set<T,U> &rhs = rhs_csc.getCategorizedSet();

            for( typename priority_list<T>::const_iterator p = m_plist.begin() ; p != m_plist.end(); p++ )
            {
                unsigned int n = 0;
                U a, b;
                if( lhs.contains(*p, a) ) n |= 1<<0;
                if( rhs.contains(*p, b) ) n |= 1<<1;
                switch( n )
                {
                    case 0: continue;
                    case 1: return false;
                    case 2: return true;
                }
                // both categories exist in the list.  Test for < or > 
                if( a < b ) { return true; }
                if( a > b ) { return false; }

                // attributes in this category are equivalent.  Check continue to next category.
            }
            // return an aribitrary true.  Reasons could be many
            return true;
        }

    protected:
        priority_list<T> m_plist;
        categorized_set <T,U> m_cset;
};

//////////////////////////////////////

enum Category{ 
    ID,
    S,
    T,
    U,
    V,
};

std::map<Category,std::string> catname;

class Start
{
    public:
        Start()
        {
            catname[ID] = "ID";
            catname[S] = "S";
            catname[T] = "T";
            catname[U] = "U";
            catname[V] = "V";
        }
}start;

class Attribute
{
    public:
        Attribute(): m_val(0) {}

        Attribute( int n ):
            m_val(n)
        {}

        Attribute( const Attribute &a ):
            m_val(a.m_val)
        {}

        virtual bool operator < (const Attribute &rhs) const
        {
            return m_val < rhs.m_val;
        }

        virtual bool operator > (const Attribute &rhs) const
        {
            return m_val > rhs.m_val;
        }

        virtual bool operator == (const Attribute &rhs) const
        {
            return m_val == rhs.m_val;
        }

        int getVal() const { return m_val; }

    private:
        int m_val;
};


typedef categorized_set<Category,Attribute> StateSet;
typedef sortable_categorized_set<Category,Attribute> SortableStateSet;


void printList( std::vector<SortableStateSet> &l )
{
    Category c[] = { ID, S, T, U, V };
    printf("%4s %4s %4s %4s %4s\n", "ID", "S", "T", "U", "V" );
    printf("%4s %4s %4s %4s %4s\n", "--", "-", "-", "-", "-" );
    for( std::vector<SortableStateSet>::iterator p = l.begin(); p != l.end(); p++ )
    {
        const StateSet &s = p->getCategorizedSet();
        for( unsigned int i = 0; i < sizeof(c)/sizeof(Category); i++ )
        {
            StateSet::const_iterator q = s.find(c[i]);
            if( q == s.end() )
                printf("%4s ", " " );
            else
                printf("%4u ", q->second.getVal() );
        }
        printf("\n" );
    }
}

int main( int argc, char **argv )
{
    StateSet ss1;

    ss1[ID] = 1;
    ss1[S] = Attribute(1);
    ss1[T] = Attribute(2);
    ss1[U] = Attribute(3);
    ss1[V] = Attribute(1);

    StateSet ss2;
    ss2[ID] = 2;
    ss2[S] = Attribute(1);
    ss2[T] = Attribute(1);

    StateSet ss3;
    ss3[ID] = 3;
    ss3[S] = Attribute(2);
    ss3[T] = Attribute(1);
    ss3[U] = Attribute(1);
    ss3[V] = Attribute(1);

    //std::vector<Category> priorityList;
    priority_list<Category>priorityList;
    //priorityList.push_back( ID );
    priorityList.push_back( S );
    priorityList.push_back( T );
    priorityList.push_back( U );
    priorityList.push_back( V );

    std::vector<SortableStateSet> l;
    l.push_back( SortableStateSet( priorityList, ss1));
    l.push_back( SortableStateSet( priorityList, ss2));
    l.push_back( SortableStateSet( priorityList, ss3));

    printf("B4 sort: (%lu)\n", l.size()  );
    printList( l );


    puts("--BEGIN Sort---" );

    std::sort( l.begin(), l.begin() + l.size());//, MyComp<Category, StateSet>(priorityList) );

    puts("--END Sort---" );

    printf("After sort: (%lu)\n", l.size() );

    printList( l );


    return 0;
}
